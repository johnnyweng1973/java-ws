package com.example.chinesetxt;

import org.apache.pdfbox.Loader;
import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.pdmodel.PDPage;
import org.apache.pdfbox.pdmodel.common.PDRectangle;
import org.apache.pdfbox.rendering.PDFRenderer;
import org.apache.pdfbox.text.PDFTextStripper;
import org.apache.pdfbox.text.TextPosition;

import javax.imageio.ImageIO;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class ExtractMathProblems {

    public static void main(String[] args) {
        String pdfPath = "2019PascalContest.pdf";
        String outputDir = "math";

        try {
        	checkPageSizes(pdfPath);
            extractMathProblems(pdfPath, outputDir);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static void extractMathProblems(String pdfPath, String outputDir) throws IOException {
        File file = new File(pdfPath);
        try (PDDocument document = Loader.loadPDF(file)) {
            // Remove the first page
            if (document.getNumberOfPages() > 1) {
                document.removePage(0);
            }

            PDFRenderer pdfRenderer = new PDFRenderer(document);

            for (int i = 0; i < document.getNumberOfPages(); i++) {
                int pageIndex = i + 1; // Adjust for the removed first page

                PDFTextStripper pdfStripper = new PDFTextStripper();
                pdfStripper.setStartPage(pageIndex);
                pdfStripper.setEndPage(pageIndex);
                String pageText = pdfStripper.getText(document);

                // Pattern to find the first line that fits the pattern
                Pattern problemPattern = Pattern.compile("^(\\d+\\. .*)$", Pattern.MULTILINE);
                Matcher matcher = problemPattern.matcher(pageText);

                if (matcher.find()) {
                    String firstLine = matcher.group(1).trim();

                    // Debug output for the first line
                    System.out.println("Page: " + pageIndex + ", First line: " + firstLine);

                    // Find the bounding box of the first line
                    BoundingBoxFinder finder = new BoundingBoxFinder(firstLine);
                    finder.setStartPage(pageIndex);
                    finder.setEndPage(pageIndex);
                    finder.getText(document); // This triggers the text extraction and bounding box calculation

                    Rectangle bbox = finder.getBoundingBox();

                    if (bbox != null) {
                        System.out.println("Bounding box for first line on page " + pageIndex + ": " + bbox);

                        BufferedImage pageImage = pdfRenderer.renderImageWithDPI(i, 300);

                        int dpi = 300;
                        float scalingFactor = dpi / 72.0f;
                        int x = (int) (bbox.x * scalingFactor);
                       // int y = (int) ((pageImage.getHeight() - bbox.y * scalingFactor) - (bbox.height * scalingFactor));
                        int y = (int) (bbox.y * scalingFactor) -30;
                        int width = (int) (bbox.width * scalingFactor) + 30;
                        int height = (int) (bbox.height * scalingFactor)+30;

                        System.out.println("Original coordinates: x=" + bbox.x + ", y=" + bbox.y + ", width=" + bbox.width + ", height=" + bbox.height);
                        System.out.println("Converted coordinates: x=" + x + ", y=" + y + ", width=" + width + ", height=" + height);

                        x = Math.max(x, 0);
                        y = Math.max(y, 0);
                        width = Math.min(width, pageImage.getWidth() - x);
                        height = Math.min(height, pageImage.getHeight() - y);

                        System.out.println("Adjusted coordinates: x=" + x + ", y=" + y + ", width=" + width + ", height=" + height);

                        BufferedImage croppedImage = pageImage.getSubimage(x, y, width, height);
                        saveImage(outputDir, pageIndex, croppedImage);
                    } else {
                        System.out.println("Bounding box is null for page: " + pageIndex);
                    }
                }
            }
        }
    }

    private static void saveImage(String outputDir, int pageIndex, BufferedImage image) throws IOException {
        Files.createDirectories(Path.of(outputDir));
        File outputfile = new File(outputDir + "/page_" + pageIndex + ".png");
        ImageIO.write(image, "png", outputfile);
        System.out.println("Saved image for page " + pageIndex + " at " + outputfile.getAbsolutePath());
    }

    private static class BoundingBoxFinder extends PDFTextStripper {
        private final List<String> searchTextParts;
        private StringBuilder accumulatedText = new StringBuilder();
        private float minX = Float.MAX_VALUE;
        private float minY = Float.MAX_VALUE;
        private float maxX = Float.MIN_VALUE;
        private float maxY = Float.MIN_VALUE;
        private boolean found = false;
        private int currentIndex = 0;

        public BoundingBoxFinder(String searchText) throws IOException {
            this.searchTextParts = List.of(searchText.split(" "));
        }

        @Override
        protected void writeString(String text, List<TextPosition> textPositions) throws IOException {
            if (found) {
                return; // Stop processing once the bounding box is found
            }

            if (currentIndex < searchTextParts.size() && searchTextParts.get(currentIndex).equals(text)) {
            	updateBoundingBox(textPositions);
                currentIndex++;
                if (currentIndex >= searchTextParts.size()) {
                    found = true;
                }
            } else {
                // Reset if the accumulated text does not match the expected part
                resetBoundingBox();
                currentIndex = 0;
            }

            super.writeString(text, textPositions);
        }

        private void resetBoundingBox() {
            minX = Float.MAX_VALUE;
            minY = Float.MAX_VALUE;
            maxX = Float.MIN_VALUE;
            maxY = Float.MIN_VALUE;
        }

        private void updateBoundingBox(List<TextPosition> textPositions) {
            for (TextPosition textPosition : textPositions) {
                minX = Math.min(minX, textPosition.getXDirAdj());
                minY = Math.min(minY, textPosition.getYDirAdj());
                maxX = Math.max(maxX, textPosition.getXDirAdj() + textPosition.getWidthDirAdj());
                maxY = Math.max(maxY, textPosition.getYDirAdj() + textPosition.getHeightDir());
            }
        }

        public Rectangle getBoundingBox() {
            if (found) {
                return new Rectangle((int) minX, (int) minY, (int) (maxX - minX), (int) (maxY - minY));
            }
            return null;
        }
    }
    
    public static void checkPageSizes(String pdfPath) throws IOException {
        File file = new File(pdfPath);
        try (PDDocument document = Loader.loadPDF(file)) {
            for (int i = 0; i < document.getNumberOfPages(); i++) {
                PDPage page = document.getPage(i);
                PDRectangle mediaBox = page.getMediaBox();
                float width = mediaBox.getWidth();
                float height = mediaBox.getHeight();
                System.out.println("Page " + (i + 1) + " size: " + width + " x " + height + " points");
            }
        }
    }
}
